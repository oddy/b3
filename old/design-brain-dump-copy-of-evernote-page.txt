Python current cracks in the system - where things dont quite fit together right -:
    * Schema: Pack is guessing types from values rather than checking against the schema like it should - refactor to Ensure vs Guess for schema vs non-schema functions.
    * Zero-copy style unpacking - see if we can do away with the buffer copy without the code going to shit.

# [parse] bytes -> schema.BytesToMessage -> AttrDict object# [pack ] AttrDict message with defaulted fields -> add field values -> schema.MessageToBytes -> bytes# We're not inheriting we're composing.# Note: Lets try messages just being AttrDicts, and the Schema class doing all the work.# todo: crack in the system - from MessageToBytes - Pack() largely ignores the explicit type given in the schema in favour of doing it's guess-type-from-value thing.# todo:       - correct way to do this would be check the incoming value's type against the schema's type and barf if its wrong.# todo:       - this means splitting pack up further into deal-with-type and prepend-header just like we planned.# todo:  ****  so then deal-with-type is either GuessType for the json UX or CheckValueTypeVsSchemaType for us.  ***GuessUserType(val) -> TYPE_XXX, bytesCheckUserType(TYPE_XX, val) ->  bytes, or TypeErrorKeys always come back as unicode, even if you supply bytes, just like in JSON.
    * DO WE WANT keys to possibly be bytes ??
    * will break attribute access with the attrdicts. 
    * but byte blocks for keys would be nice - if say we want to stick hashes in there ??
    * we were never able to use byte blocks as keys with JSON and we've done fine there so far.
    * # Note: if the field names are byte strings on py 3, and user addes a property with string-string name, and custom is on
    * # Note: we end up with TWO fields named the same, but one is a byte key and one is a str key.
    * So allowing byte-keys sounds like a fucking awful idea. 
    * about map keys, protobufs says "where the key_type can be any integral or string type (so, any scalar type except for floating point types and bytes)."
    * So they dont allow it, and it looks like they dont with their message field names either, that being in the proto language itself. 
    * JSON map keys are their strings with the \u escaping (so not utf8).
    * so decided : field names and dict keys are always and only utf8 strings.   Passing bytes is an error.

TYPE_UTF8 rationale: everyone knows that utf8 is strings nowadays. We dont need a TYPE_STRING because that will confuse py2-py3 people.They will know a TYPE_UTF8 will turn into a u'' on both versions, and Go people already know that utf8 bytes and strings are the same type ANYWAY.STRETCH GOAL Parsing:   zero-copy buffer returning.All the composite structure stuff is actually dependent on the language end and what you want to ultimately do with composite data on the language end. This forces us to have the composite stuff broken up and repeated a bit for each of the the 3 different APIs. At least in Python, this is unavoidable.# Item:# [BYTE type] [VARINT tag] | <[VARINT namelen] [UTF8 name]> [VARINT len] [BYTES data]# ---type---- ------------------- key ------------------- ---------- value --------keys/tags
    * the Type byte's high bit is 'key(tag) follows yes/no'
    * type bytes 2nd highest bit is 'key(tag) is string vs int'

UPDATE# * Tag 0 is [NOT] 'name string follows'.#   - we are gonna switch this to a second bit.#   - tag 0 being reserved violates the principle of least surprise - lots of lists starting at 1 instead of 0,#   - converted to a list the tagged items first item will be [0] but accessed by tag it will be [1].#   - devs Learned Behaviour is that 'stuff starts at 0'. Remember the outcry over visual basic#   - drops us to 64 types usable instead of 128, but even with 32 reserved for usertypes, that still gives us 32 for our zoo.'end of input counts as an implicit END marker''small types still have a length'null, true, false still have a length of 0.Pro: makes code simpler.  Everything (except END) has a length no matter what. Simpler pack/unpack code.Con: makes packed data bigger if you have lots of nulls trues and falses.
    * only matters in degenerate cases with large numbers of trues and falses in which case the dev should be rolling a bitmap or something
    * there is a performance cost parsing all those extra 0-lens but if we have a fast exit in the decode_varint routine for 0 that should help. (maybe.)

This means that the varints and fixed formatwe should reserve a range for user types, like msgpack does.we can use it for weird classes and stuff so they can be bags. That way a tag doesn't have to signify a class and need its own deserializer, we could from_dict it etc.str maps to TYPE_BYTES on python2.If you want unicode out, pass unicode in. (see also json, which 'upgrades' everything to unicode anyway in our current projects and they dont seem to mind.
    * This illustrates how unicode fuckery is not the serialization library's fault or problem, you gotta deal with your constant strings back where they are defined in your source!!

# Any time the SYSTEM needs a string (e.g for key names), we use EnsureUtf8() here, but if we're processing USER strings,# we use the logic in PackBasicType, which turns py2 str into TYPE_BYTES because people should be using u' ' on their constants.PackBasicTypr is for basic data types only.
    * make it barf on lists, dicts, and anything it doesnt know
    * because dicts and lists and composite types need to be packed first anyway, so they're just bytes at this level.

we cant have basic type overrides because how would they happen deep down in the recursive packings.if we want to map a language type into multiple possible storage types we have to have an override registry=== In the tagged-message layer ===
    * where a numbered tag with a name, and a custom name field are both present, the numbered tag field takes precedence. This is good security. We want the custom name thing to be an overlay on the top, but we dont want it to reach back into the more 'deep' or entrenched fields and risk fucking with them.
    * 

