
I have my binary format design, i think i've accounted for the basic data types people use most often. 

Looking at the 13 or so major languages that ZMQ supports, and their data types, 
A) am i missing any obvious super prevalent ones?


B) the "python Decimal problem"
- a lot of languages support an arbitray precision fixed point decimal numbers type, as well as the usual floating point. 

at the moment if someone puts a 'decimal' python type in to my binary format, they're gonna get a float back out.

Because these types all converge on one concrete language type each:

# --- Basic types ---
B3_NULL     = 6    # None.                                                      for None.
B3_BOOL     = 5    # True or False.                                             for bool.
B3_BYTES    = 4    # List of bytes (bytearray?).           Note: str in py2.    for bytes.
B3_UTF8     = 7    # UTF8 byte strings.                    for str in py3 and unicode in py2.

# --- Funky types ---
B3_INT64    = 8    # signed 64bit integer                  faster & medium      for ints.
B3_VARINT   = 8    # signed varint, zigzag encoded.        slower & small/large for ints.
B3_UVARINT  = 9    # unsigned varint                       slower & small/large for ints.

B3_FLOAT64  = 10   # IEEE754 64bit signed float.           faster & medium      for floats.
B3_DECIMAL  = 11   # Arbitrary Precision decimals.         slower & small/large for floats.

B3_STAMP64  = 12   # Signed 64bit unix ns, no TZ           faster & medium      for datetime. (yr 1678-2262)
B3_SCHED    = 13   # Arb Prec unix sec, opt ns,offset,TZ.  slower & small/large for datetime.


(for ints, for floats, etc)

There are 3 ways to solve "wanting a decimal back out"
1) Tough shit, you're getting a float.  [this is what we have now]
2) A zoo of 'sub types' and a big registry of language specific shit (and adding a 'sub type' field to the binary format, so it can know what to turn the data back into on the language side (do i want decimal or float or something else etc)
3) One single "select alternate type" bit in the binary format, that picks between the normal Float and the alternate Decimal.

So my question for (B) is,  
Is approach (3) good enough for all the major types? Can i get away with only ever having 2 possible fan-out types?

Answering that requires an inventory of the data types in each of the major langyages, and ideally whats prevalent and used mainly by them.



To be clear:

I'm not asking for a conversation about what the most ideal thing to do would be if we all had infinite time and infinite money. And i'm not asking for a big rundown of all the types a language has - thats just a means to this end:

I'm asking, For Each Language:
1) are there any other in-prevalent-common-use complicated types apart from int-like, float-like and time-like? 
and
2) For each of those, will 2 possible language-side output types satisfy more than 80% of the common uses?



